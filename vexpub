--sort v workspace
local workspace = game:GetService("Workspace")
local runService = game:GetService("RunService")
local function createFolder(name)
    local folder = Instance.new("Folder")
    folder.Name = name
    folder.Parent = workspace
    return folder
end
local function hasAllRequiredChildren(model)
    local requiredChildren = {
        "Armor", "LeftFoot", "LeftHand", "LeftLowerArm", "LeftLowerLeg", "LeftUpperArm",
        "LeftUpperLeg", "RightFoot", "RightHand", "RightLowerArm", "RightLowerLeg",
        "RightUpperArm", "RightUpperLeg", "Torso", "Head", "HumanoidRootPart",
        "LowerTorso", "AnimationController"
    }

    for _, childName in ipairs(requiredChildren) do
        if not model:FindFirstChild(childName) then
            return false
        end
    end
    return true
end
local function isScientist(model)
    local nametag = model:FindFirstChild("Head"):FindFirstChild("Nametag")
    if nametag and nametag:FindFirstChild("tag") then
        return nametag.tag.ContentText == "Shylou2644"
    end
    return false
end
local function isTeammate(model)
    local head = model:FindFirstChild("Head")
    if head then
        local dot2 = head:FindFirstChild("Dot2")
        if dot2 and dot2.Enabled then
            return true
        end
    end
    return false
end
local function isSleeper(model)
    local torso = model:FindFirstChild("Torso")
    if torso then
        local isTorsoHorizontal = torso.CFrame.UpVector.Y < 0.5
        return isTorsoHorizontal
    end
    return false
end
local function moveToFolder(model, playersFolder, scientistsFolder, teammatesFolder, psleepersFolder, tsleepersFolder)
    if hasAllRequiredChildren(model) then
        if isTeammate(model) then
            if isSleeper(model) then
                if model.Parent ~= tsleepersFolder then
                    model.Parent = tsleepersFolder
                end
            else
                if model.Parent ~= teammatesFolder then
                    model.Parent = teammatesFolder
                end
            end
        elseif isScientist(model) then
            if model.Parent ~= scientistsFolder then
                model.Parent = scientistsFolder
            end
        else
            if isSleeper(model) then
                if model.Parent ~= psleepersFolder then
                    model.Parent = psleepersFolder
                end
            else
                if model.Parent ~= playersFolder then
                    model.Parent = playersFolder
                end
            end
        end
    end
end
local playersFolder = createFolder("Players")
local scientistsFolder = createFolder("Scientists")
local teammatesFolder = createFolder("Teammates")
local psleepersFolder = createFolder("Psleepers")
local tsleepersFolder = createFolder("Tsleepers")

-- Function to check and update model folder based on status change
local function updateModelFolder(model)
    moveToFolder(model, playersFolder, scientistsFolder, teammatesFolder, psleepersFolder, tsleepersFolder)
end

-- Check existing models in the workspace and move them to the appropriate folder
for _, item in ipairs(workspace:GetChildren()) do
    if item:IsA("Model") then
        updateModelFolder(item)
    end
end

-- Monitor workspace for new models
workspace.ChildAdded:Connect(function(child)
    if child:IsA("Model") then
        updateModelFolder(child)
    end
end)

-- Monitor for the Players, Scientists, Teammates, Psleepers, and Tsleepers folder removal
workspace.DescendantRemoving:Connect(function(descendant)
    if descendant == playersFolder then
        playersFolder = createFolder("Players")
    end

    if descendant == scientistsFolder then
        scientistsFolder = createFolder("Scientists")
    end

    if descendant == teammatesFolder then
        teammatesFolder = createFolder("Teammates")
    end

    if descendant == psleepersFolder then
        psleepersFolder = createFolder("Psleepers")
    end

    if descendant == tsleepersFolder then
        tsleepersFolder = createFolder("Tsleepers")
    end
end)

-- Continuous updates for folder assignment based on changing states
runService.Stepped:Connect(function()
    -- Check models in Players folder
    for _, model in ipairs(playersFolder:GetChildren()) do
        if model:IsA("Model") and hasAllRequiredChildren(model) then
            -- Move to appropriate folder if status changes
            updateModelFolder(model)
        end
    end
    
    -- Check models in Teammates folder
    for _, model in ipairs(teammatesFolder:GetChildren()) do
        if model:IsA("Model") and hasAllRequiredChildren(model) then
            -- Move back to appropriate folder if status changes
            updateModelFolder(model)
        end
    end

    -- Check models in Scientists folder
    for _, model in ipairs(scientistsFolder:GetChildren()) do
        if model:IsA("Model") and hasAllRequiredChildren(model) then
            -- Move to another folder if no longer a scientist
            updateModelFolder(model)
        end
    end

    -- Check models in Psleepers folder
    for _, model in ipairs(psleepersFolder:GetChildren()) do
        if model:IsA("Model") and hasAllRequiredChildren(model) then
            -- Move to another folder if no longer a sleeper
            updateModelFolder(model)
        end
    end

    -- Check models in Tsleepers folder
    for _, model in ipairs(tsleepersFolder:GetChildren()) do
        if model:IsA("Model") and hasAllRequiredChildren(model) then
            -- Move to another folder if no longer a sleeper
            updateModelFolder(model)
        end
    end
end)
runService.Stepped:Connect(function()
    for _, model in ipairs(workspace:GetChildren()) do
        if model:IsA("Model") and hasAllRequiredChildren(model) then
            updateModelFolder(model)
        end
    end
end)
-- Define the required parts for boats and ATVs
local boatParts = {
    "Color", "Hull", "Metal", "Seats", "SteeringWheel", "WindBlock"
}

local atvParts = {
    "BackLeftRim", "BackLeftW", "BackRightRim", "BackRightW", "Frame",
    "FrontLeftRim", "FrontLeftW", "FrontRightRim", "FrontRightW", "Grip",
    "HandleBars", "Plastics", "Plastics2", "Seat", "LeftBackWH",
    "LeftFrontWH", "RightBackWH", "RightFrontWH"
}

-- Helper function to check if a model contains all required parts
local function hasRequiredParts(model, requiredParts)
    for _, partName in ipairs(requiredParts) do
        if not model:FindFirstChild(partName) then
            return false
        end
    end
    return true
end

-- Function to enable massless property on ATV parts
local function enableMassless(atvModel)
    for _, part in ipairs(atvModel:GetDescendants()) do
        if part:IsA("BasePart") then
            part.Massless = true
        end
    end
end

-- Function to disable custom physical properties for parts
local function disableCustomPhysicalProperties(model)
    for _, part in ipairs(model:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CustomPhysicalProperties = nil
        end
    end
end

-- Function to delete specific objects in the 'Frame' part
local function deleteObjectsInFrame(model)
    local objectsToDelete = {
        "BLCC", "BLSpring", "BRCC", "BRSpring", "FLCC", "FLSpring", "FRCC", "FRSpring"
    }

    local frame = model:FindFirstChild("Frame")
    if frame then
        for _, objectName in ipairs(objectsToDelete) do
            local object = frame:FindFirstChild(objectName)
            if object then
                object:Destroy()
            end
        end
    end
end

-- Function to modify specific parts in the ATV model
local function modifyAtvParts(model)
    local partsToModify = {
        "LeftBackWH", "LeftFrontWH", "RightBackWH", "RightFrontWH", 
        "FrontRightW", "FrontLeftRim", "FrontLeftW", "FrontRightRim", 
        "BackRightW", "BackLeftRim", "BackLeftW", "BackRightRim"
    }

    for _, partName in ipairs(partsToModify) do
        local part = model:FindFirstChild(partName)
        if part and part:IsA("BasePart") then
            part.CanCollide = false
            part.CanTouch = false
            part.CanQuery = false
            part.Transparency = 1
        end
    end
end

-- Create folders for Boats and ATVs if they don't exist
local boatsFolder = workspace:FindFirstChild("Boats") or Instance.new("Folder")
boatsFolder.Name = "Boats"
boatsFolder.Parent = workspace

local atvsFolder = workspace:FindFirstChild("ATVs") or Instance.new("Folder")
atvsFolder.Name = "ATVs"
atvsFolder.Parent = workspace

-- Function to update a model's properties
local function updateModelProperties(model)
    if hasRequiredParts(model, atvParts) then
        enableMassless(model)
        deleteObjectsInFrame(model)
        modifyAtvParts(model)
        disableCustomPhysicalProperties(model)
    end
end

-- Function to handle a model and move it to the correct folder
local function handleModel(model)
    if model:IsA("Model") and model.Name == "Model" then
        if hasRequiredParts(model, boatParts) then
            model.Parent = boatsFolder
        elseif hasRequiredParts(model, atvParts) then
            model.Parent = atvsFolder
        end
    end
end

-- Function to process all models in the workspace and folders
local function processAllModels()
    for _, obj in ipairs(workspace:GetChildren()) do
        handleModel(obj)
    end

    for _, boat in ipairs(boatsFolder:GetChildren()) do
        if boat:IsA("Model") then
            -- Add any specific boat logic here if needed
        end
    end

    for _, atv in ipairs(atvsFolder:GetChildren()) do
        if atv:IsA("Model") then
            updateModelProperties(atv)
        end
    end
end

-- Continuously check for new models and update folders and models
task.spawn(function()
    while true do
        processAllModels()
        task.wait(1) -- Prevent performance issues
    end
end)


---VEXPUB
local Load = loadstring or _G.load
--FUNcITONS

local fovzoom = [[local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local camera = game.Workspace.CurrentCamera

local defaultFOV = 120
local zoomedFOV = 50

camera.FieldOfView = defaultFOV

local function executeFOVScript()
    while true do
        RunService.RenderStepped:Wait()
        
        -- Check if right mouse button is held down
        if UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2) then
            -- Set the FOV to zoomedFOV
            camera.FieldOfView = zoomedFOV
        else
            -- Set the FOV back to defaultFOV
            camera.FieldOfView = defaultFOV
        end
    end
end

executeFOVScript()

]]

local fpsboost = [[local decalsyeeted = true 
local g = game
local w = g.Workspace
local l = g.Lighting
local t = w.Terrain
t.WaterWaveSize = 0
t.WaterWaveSpeed = 0
t.WaterReflectance = 0
t.WaterTransparency = 0
l.GlobalShadows = false
l.FogEnd = 9e9
l.Brightness = 0
settings().Rendering.QualityLevel = "Level01"
for i,v in pairs(g:GetDescendants()) do
   if v:IsA("Part") or v:IsA("Union") or v:IsA("MeshPart") or v:IsA("CornerWedgePart") or v:IsA("TrussPart") then
       v.Material = "Plastic"
v.Reflectance = 0
elseif v:IsA("Decal") and decalsyeeted then
v.Transparency = 1
elseif v:IsA("ParticleEmitter") or v:IsA("Trail") then
v.Lifetime = NumberRange.new(0)
elseif v:IsA("Explosion") then
v.BlastPressure = 1
v.BlastRadius = 1
   end
end
for i,e in pairs(l:GetChildren()) do
if e:IsA("BlurEffect") or e:IsA("SunRaysEffect") or e:IsA("ColorCorrectionEffect") or e:IsA("BloomEffect") or e:IsA("DepthOfFieldEffect") then
e.Enabled = false
end
end

]]

local hitlogs = [[local notifications = {}
local center = (workspace.CurrentCamera.ViewportSize / 2)

local function hitmarker_update()
    for i = 1, #notifications do
        notifications[i].Position = Vector2.new(center.X, center.Y + 50 + (i * 18))
    end
end

local function animate_hitlog(hitlog)
    local startY = hitlog.Position.Y + 20
    local endY = hitlog.Position.Y
    local duration = 0.62
    local steps = 20
    local stepTime = duration / steps

    for step = 1, steps do
        task.wait(stepTime)
        local progress = step / steps
        local currentY = startY + (endY - startY) * progress
        hitlog.Position = Vector2.new(hitlog.Position.X, currentY)
    end
end

local function hitmarker(Name, Damage, Duration)
    task.spawn(function()
        local hitlog = Drawing.new('Text')
        hitlog.Size = 14.2
        hitlog.Font = 2
        hitlog.Text = " Vex.Pub| " .. Name .. " | " .. math.floor(Damage) .. "Hp"
        hitlog.Visible = true
        hitlog.ZIndex = 3
        hitlog.Center = true
        hitlog.Color = Color3.fromRGB(144, 0, 144)
        hitlog.Outline = false
        table.insert(notifications, hitlog)
        hitmarker_update()
        animate_hitlog(hitlog)
        wait(Duration)
        table.remove(notifications, table.find(notifications, hitlog))
        hitmarker_update()
        hitlog:Remove()
    end)
end

game:GetService("LogService").MessageOut:Connect(function(message)
    local Name = message:match("->([%w]+)")
    local HealthBfr, HealthAfr = message:match("(%d+%.?%d)->(%d+%.?%d)hp")
    local Damage = tonumber(HealthBfr) - tonumber(HealthAfr)
    if Name and HealthBfr and HealthAfr and Damage then
        hitmarker(Name, Damage, 4)
    end
end)

]]

local xray = [[local UserInputService = game:GetService("UserInputService")
local XRayEnabled = false
local XRayTransparency = 0.9 

local requiredParts = {
    "Hitbox", "Union", "Enclosure", "Frame", "LeftHandle", "LeftHinge", 
    "LeftWall", "RightHandle", "RightHinge", "RightWall", "Handle", 
    "Hinge", "Wall", "Meshes/triangle", "Hitbox2"
}

-- Table to store original transparencies
local originalTransparency = {}

local function applyXRay(value)
    for _, model in ipairs(game:GetService("Workspace"):GetChildren()) do
        if model:IsA("Model") then
            local hasRequiredPart = false
            
            -- Check if the model contains any required parts
            for _, part in ipairs(model:GetDescendants()) do
                if part:IsA("BasePart") and table.find(requiredParts, part.Name) then
                    hasRequiredPart = true
                    break
                end
            end
            
            -- If it has a required part, apply transparency to all descendants
            if hasRequiredPart then
                for _, part in ipairs(model:GetDescendants()) do
                    if part:IsA("BasePart") then
                        -- Store original transparency if not already stored
                        if not originalTransparency[part] then
                            originalTransparency[part] = part.Transparency
                        end
                        -- Apply new transparency
                        part.Transparency = value
                    end
                end
            end
        end
    end
end

local function restoreTransparency()
    for part, originalValue in pairs(originalTransparency) do
        if part and part:IsA("BasePart") then
            part.Transparency = originalValue
        end
    end
    -- Clear the original transparency table
    originalTransparency = {}
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed then
        if input.KeyCode == Enum.KeyCode.V then
            XRayEnabled = not XRayEnabled
            if XRayEnabled then
                applyXRay(XRayTransparency)
            else
                restoreTransparency()
            end
        end
    end
end)
]]
local Freecam = [[
------------------------------------------------------------------------
-- Freecam
-- Cinematic free camera for spectating and video production.
------------------------------------------------------------------------

local pi    = math.pi
local abs   = math.abs
local clamp = math.clamp
local exp   = math.exp
local rad   = math.rad
local sign  = math.sign
local sqrt  = math.sqrt
local tan   = math.tan

local ContextActionService = game:GetService("ContextActionService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
if not LocalPlayer then
	Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
	LocalPlayer = Players.LocalPlayer
end

local Camera = Workspace.CurrentCamera
Workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
	local newCamera = Workspace.CurrentCamera
	if newCamera then
		Camera = newCamera
	end
end)

------------------------------------------------------------------------
local TOGGLE_INPUT_PRIORITY = Enum.ContextActionPriority.Low.Value
local INPUT_PRIORITY = Enum.ContextActionPriority.High.Value
local FREECAM_MACRO_KB = {Enum.KeyCode.L}

local NAV_GAIN = Vector3.new(1, 1, 1)*64
local PAN_GAIN = Vector2.new(0.75, 1)*8
local FOV_GAIN = 300

local PITCH_LIMIT = rad(90)

local VEL_STIFFNESS = 1.5
local PAN_STIFFNESS = 1.0
local FOV_STIFFNESS = 4.0

------------------------------------------------------------------------

local Spring = {} do
	Spring.__index = Spring

	function Spring.new(freq, pos)
		local self = setmetatable({}, Spring)
		self.f = freq
		self.p = pos
		self.v = pos*0
		return self
	end

	function Spring:Update(dt, goal)
		local f = self.f*2*pi
		local p0 = self.p
		local v0 = self.v

		local offset = goal - p0
		local decay = exp(-f*dt)

		local p1 = goal + (v0*dt - offset*(f*dt + 1))*decay
		local v1 = (f*dt*(offset*f - v0) + v0)*decay

		self.p = p1
		self.v = v1

		return p1
	end

	function Spring:Reset(pos)
		self.p = pos
		self.v = pos*0
	end
end

------------------------------------------------------------------------

local cameraPos = Vector3.new()
local cameraRot = Vector2.new()
local cameraFov = 0

local velSpring = Spring.new(VEL_STIFFNESS, Vector3.new())
local panSpring = Spring.new(PAN_STIFFNESS, Vector2.new())
local fovSpring = Spring.new(FOV_STIFFNESS, 0)

------------------------------------------------------------------------

local Input = {} do
	local thumbstickCurve do
		local K_CURVATURE = 2.0
		local K_DEADZONE = 0.15

		local function fCurve(x)
			return (exp(K_CURVATURE*x) - 1)/(exp(K_CURVATURE) - 1)
		end

		local function fDeadzone(x)
			return fCurve((x - K_DEADZONE)/(1 - K_DEADZONE))
		end

		function thumbstickCurve(x)
			return sign(x)*clamp(fDeadzone(abs(x)), 0, 1)
		end
	end

	local gamepad = {
		ButtonX = 0,
		ButtonY = 0,
		DPadDown = 0,
		DPadUp = 0,
		ButtonL2 = 0,
		ButtonR2 = 0,
		Thumbstick1 = Vector2.new(),
		Thumbstick2 = Vector2.new(),
	}

	local keyboard = {
		W = 0,
		A = 0,
		S = 0,
		D = 0,
		E = 0,
		Q = 0,
		U = 0,
		H = 0,
		J = 0,
		K = 0,
		I = 0,
		Y = 0,
		Up = 0,
		Down = 0,
		LeftShift = 0,
		RightShift = 0,
	}

	local mouse = {
		Delta = Vector2.new(),
		MouseWheel = 0,
	}

	local NAV_GAMEPAD_SPEED  = Vector3.new(1, 1, 1)
	local NAV_KEYBOARD_SPEED = Vector3.new(1, 1, 1)
	local PAN_MOUSE_SPEED    = Vector2.new(1, 1)*(pi/64)
	local PAN_GAMEPAD_SPEED  = Vector2.new(1, 1)*(pi/8)
	local FOV_WHEEL_SPEED    = 1.0
	local FOV_GAMEPAD_SPEED  = 0.25
	local NAV_ADJ_SPEED      = 0.75
	local NAV_SHIFT_MUL      = 0.25

	local navSpeed = 1

	function Input.Vel(dt)
		navSpeed = clamp(navSpeed + dt*(keyboard.Up - keyboard.Down)*NAV_ADJ_SPEED, 0.01, 4)

		local kGamepad = Vector3.new(
			thumbstickCurve(gamepad.Thumbstick1.x),
			thumbstickCurve(gamepad.ButtonR2) - thumbstickCurve(gamepad.ButtonL2),
			thumbstickCurve(-gamepad.Thumbstick1.y)
		)*NAV_GAMEPAD_SPEED

		local kKeyboard = Vector3.new(
			keyboard.D - keyboard.A + keyboard.K - keyboard.H,
			keyboard.E - keyboard.Q + keyboard.I - keyboard.Y,
			keyboard.S - keyboard.W + keyboard.J - keyboard.U
		)*NAV_KEYBOARD_SPEED

		local shift = UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) or UserInputService:IsKeyDown(Enum.KeyCode.RightShift)

		return (kGamepad + kKeyboard)*(navSpeed*(shift and NAV_SHIFT_MUL or 1))
	end

	function Input.Pan(dt)
		local kGamepad = Vector2.new(
			thumbstickCurve(gamepad.Thumbstick2.y),
			thumbstickCurve(-gamepad.Thumbstick2.x)
		)*PAN_GAMEPAD_SPEED
		local kMouse = mouse.Delta*PAN_MOUSE_SPEED
		mouse.Delta = Vector2.new()
		return kGamepad + kMouse
	end

	function Input.Fov(dt)
		local kGamepad = (gamepad.ButtonX - gamepad.ButtonY)*FOV_GAMEPAD_SPEED
		local kMouse = mouse.MouseWheel*FOV_WHEEL_SPEED
		mouse.MouseWheel = 0
		return kGamepad + kMouse
	end

	do
		local function Keypress(action, state, input)
			keyboard[input.KeyCode.Name] = state == Enum.UserInputState.Begin and 1 or 0
			return Enum.ContextActionResult.Sink
		end

		local function GpButton(action, state, input)
			gamepad[input.KeyCode.Name] = state == Enum.UserInputState.Begin and 1 or 0
			return Enum.ContextActionResult.Sink
		end

		local function MousePan(action, state, input)
			local delta = input.Delta
			mouse.Delta = Vector2.new(-delta.y, -delta.x)
			return Enum.ContextActionResult.Sink
		end

		local function Thumb(action, state, input)
			gamepad[input.KeyCode.Name] = input.Position
			return Enum.ContextActionResult.Sink
		end

		local function Trigger(action, state, input)
			gamepad[input.KeyCode.Name] = input.Position.z
			return Enum.ContextActionResult.Sink
		end

		local function MouseWheel(action, state, input)
			mouse[input.UserInputType.Name] = -input.Position.z
			return Enum.ContextActionResult.Sink
		end

		local function Zero(t)
			for k, v in pairs(t) do
				t[k] = v*0
			end
		end

		function Input.StartCapture()
			ContextActionService:BindActionAtPriority("FreecamKeyboard", Keypress, false, INPUT_PRIORITY,
				Enum.KeyCode.W, Enum.KeyCode.U,
				Enum.KeyCode.A, Enum.KeyCode.H,
				Enum.KeyCode.S, Enum.KeyCode.J,
				Enum.KeyCode.D, Enum.KeyCode.K,
				Enum.KeyCode.E, Enum.KeyCode.I,
				Enum.KeyCode.Q, Enum.KeyCode.Y,
				Enum.KeyCode.Up, Enum.KeyCode.Down
			)
			ContextActionService:BindActionAtPriority("FreecamMousePan",          MousePan,   false, INPUT_PRIORITY, Enum.UserInputType.MouseMovement)
			ContextActionService:BindActionAtPriority("FreecamMouseWheel",        MouseWheel, false, INPUT_PRIORITY, Enum.UserInputType.MouseWheel)
			ContextActionService:BindActionAtPriority("FreecamGamepadButton",     GpButton,   false, INPUT_PRIORITY, Enum.KeyCode.ButtonX, Enum.KeyCode.ButtonY)
			ContextActionService:BindActionAtPriority("FreecamGamepadTrigger",    Trigger,    false, INPUT_PRIORITY, Enum.KeyCode.ButtonR2, Enum.KeyCode.ButtonL2)
			ContextActionService:BindActionAtPriority("FreecamGamepadThumbstick", Thumb,      false, INPUT_PRIORITY, Enum.KeyCode.Thumbstick1, Enum.KeyCode.Thumbstick2)
		end

		function Input.StopCapture()
			navSpeed = 1
			Zero(gamepad)
			Zero(keyboard)
			Zero(mouse)
			ContextActionService:UnbindAction("FreecamKeyboard")
			ContextActionService:UnbindAction("FreecamMousePan")
			ContextActionService:UnbindAction("FreecamMouseWheel")
			ContextActionService:UnbindAction("FreecamGamepadButton")
			ContextActionService:UnbindAction("FreecamGamepadTrigger")
			ContextActionService:UnbindAction("FreecamGamepadThumbstick")
		end
	end
end

local function GetFocusDistance(cameraFrame)
	local znear = 0.1
	local viewport = Camera.ViewportSize
	local projy = 2*tan(cameraFov/2)
	local projx = viewport.x/viewport.y*projy
	local fx = cameraFrame.rightVector
	local fy = cameraFrame.upVector
	local fz = cameraFrame.lookVector

	local minVect = Vector3.new()
	local minDist = 512

	for x = 0, 1, 0.5 do
		for y = 0, 1, 0.5 do
			local cx = (x - 0.5)*projx
			local cy = (y - 0.5)*projy
			local offset = fx*cx - fy*cy + fz
			local origin = cameraFrame.p + offset*znear
			local _, hit = Workspace:FindPartOnRay(Ray.new(origin, offset.unit*minDist))
			local dist = (hit - origin).magnitude
			if minDist > dist then
				minDist = dist
				minVect = offset.unit
			end
		end
	end

	return fz:Dot(minVect)*minDist
end

------------------------------------------------------------------------

local function StepFreecam(dt)
	local vel = velSpring:Update(dt, Input.Vel(dt))
	local pan = panSpring:Update(dt, Input.Pan(dt))
	local fov = fovSpring:Update(dt, Input.Fov(dt))

	local zoomFactor = sqrt(tan(rad(70/2))/tan(rad(cameraFov/2)))

	cameraFov = clamp(cameraFov + fov*FOV_GAIN*(dt/zoomFactor), 1, 120)
	cameraRot = cameraRot + pan*PAN_GAIN*(dt/zoomFactor)
	cameraRot = Vector2.new(clamp(cameraRot.x, -PITCH_LIMIT, PITCH_LIMIT), cameraRot.y%(2*pi))

	local cameraCFrame = CFrame.new(cameraPos)*CFrame.fromOrientation(cameraRot.x, cameraRot.y, 0)*CFrame.new(vel*NAV_GAIN*dt)
	cameraPos = cameraCFrame.p

	Camera.CFrame = cameraCFrame
	Camera.Focus = cameraCFrame*CFrame.new(0, 0, -GetFocusDistance(cameraCFrame))
	Camera.FieldOfView = cameraFov
end

------------------------------------------------------------------------

local PlayerState = {} do
	local mouseBehavior
	local mouseIconEnabled
	local cameraType
	local cameraFocus
	local cameraCFrame
	local cameraFieldOfView
	local screenGuis = {}
	local coreGuis = {
		Backpack = true,
		Chat = true,
		Health = true,
		PlayerList = true,
	}
	local setCores = {
		BadgesNotificationsActive = true,
		PointsNotificationsActive = true,
	}

	-- Save state and set up for freecam
	function PlayerState.Push()
		for name in pairs(coreGuis) do
			coreGuis[name] = StarterGui:GetCoreGuiEnabled(Enum.CoreGuiType[name])
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType[name], false)
		end
		for name in pairs(setCores) do
			setCores[name] = StarterGui:GetCore(name)
			StarterGui:SetCore(name, false)
		end
		local playergui = LocalPlayer:FindFirstChildOfClass("PlayerGui")
		if playergui then
			for _, gui in pairs(playergui:GetChildren()) do
				if gui:IsA("ScreenGui") and gui.Enabled then
					screenGuis[#screenGuis + 1] = gui
					gui.Enabled = false
				end
			end
		end

		cameraFieldOfView = Camera.FieldOfView
		Camera.FieldOfView = 70

		cameraType = Camera.CameraType
		Camera.CameraType = Enum.CameraType.Custom

		cameraCFrame = Camera.CFrame
		cameraFocus = Camera.Focus

		mouseIconEnabled = UserInputService.MouseIconEnabled
		UserInputService.MouseIconEnabled = false

		mouseBehavior = UserInputService.MouseBehavior
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	end

	-- Restore state
	function PlayerState.Pop()
		for name, isEnabled in pairs(coreGuis) do
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType[name], isEnabled)
		end
		for name, isEnabled in pairs(setCores) do
			StarterGui:SetCore(name, isEnabled)
		end
		for _, gui in pairs(screenGuis) do
			if gui.Parent then
				gui.Enabled = true
			end
		end

		Camera.FieldOfView = cameraFieldOfView
		cameraFieldOfView = nil

		Camera.CameraType = cameraType
		cameraType = nil

		Camera.CFrame = cameraCFrame
		cameraCFrame = nil

		Camera.Focus = cameraFocus
		cameraFocus = nil

		UserInputService.MouseIconEnabled = mouseIconEnabled
		mouseIconEnabled = nil

		UserInputService.MouseBehavior = mouseBehavior
		mouseBehavior = nil
	end
end

local function StartFreecam()
	local cameraCFrame = Camera.CFrame
	cameraRot = Vector2.new(cameraCFrame:toEulerAnglesYXZ())
	cameraPos = cameraCFrame.p
	cameraFov = Camera.FieldOfView

	velSpring:Reset(Vector3.new())
	panSpring:Reset(Vector2.new())
	fovSpring:Reset(0)

	PlayerState.Push()
	RunService:BindToRenderStep("Freecam", Enum.RenderPriority.Camera.Value, StepFreecam)
	Input.StartCapture()
end

local function StopFreecam()
	Input.StopCapture()
	RunService:UnbindFromRenderStep("Freecam")
	PlayerState.Pop()
end

------------------------------------------------------------------------

do
	local enabled = false

	local function ToggleFreecam()
		if enabled then
			StopFreecam()
		else
			StartFreecam()
		end
		enabled = not enabled
	end

	local function CheckMacro(macro)
		for i = 1, #macro - 1 do
			if not UserInputService:IsKeyDown(macro[i]) then
				return
			end
		end
		ToggleFreecam()
	end

	local function HandleActivationInput(action, state, input)
		if state == Enum.UserInputState.Begin then
			if input.KeyCode == FREECAM_MACRO_KB[#FREECAM_MACRO_KB] then
				CheckMacro(FREECAM_MACRO_KB)
			end
		end
		return Enum.ContextActionResult.Pass
	end

	ContextActionService:BindActionAtPriority("FreecamToggle", HandleActivationInput, false, TOGGLE_INPUT_PRIORITY, FREECAM_MACRO_KB[#FREECAM_MACRO_KB])
end
]]
local ESP1 = [[local BoxESP = {}
function BoxESP.Create(Player)
    local Box = Drawing.new("Square")
    Box.Visible = false
    Box.Color = Color3.fromRGB(194, 17, 17)
    Box.Filled = false
    Box.Transparency = 0.50
    Box.Thickness = 3

    local Updater

    local function UpdateBox()
        if Player and Player:IsA("Model") and Player:FindFirstChild("HumanoidRootPart") and Player:FindFirstChild("Head") then
            local Target2dPosition, IsVisible = workspace.CurrentCamera:WorldToViewportPoint(Player.HumanoidRootPart.Position)
            local scale_factor = 1 / (Target2dPosition.Z * math.tan(math.rad(workspace.CurrentCamera.FieldOfView * 0.5)) * 2) * 100
            local width, height = math.floor(40 * scale_factor), math.floor(62 * scale_factor)

            Box.Visible = IsVisible
            Box.Size = Vector2.new(width, height)
            Box.Position = Vector2.new(Target2dPosition.X - Box.Size.X / 2, Target2dPosition.Y - Box.Size.Y / 2)
        else
            Box.Visible = false
            if not Player then
                Box:Remove()
                Updater:Disconnect()
            end
        end
    end

    Updater = game:GetService("RunService").RenderStepped:Connect(UpdateBox)

    return Box
end

local Boxes = {}

local function EnableBoxESP()
    for _, Player in pairs(game:GetService("Workspace"):GetChildren()) do
        if Player:IsA("Model") and Player:FindFirstChild("HumanoidRootPart") and Player:FindFirstChild("Head") then
            local Box = BoxESP.Create(Player)
            table.insert(Boxes, Box)
        end
    end
end

game.Workspace.DescendantAdded:Connect(function(i)
    if i:IsA("Model") and i:FindFirstChild("HumanoidRootPart") and i:FindFirstChild("Head") then
        local Box = BoxESP.Create(i)
        table.insert(Boxes, Box)
    end
end)

EnableBoxESP()

local SelectPart = "Head"
local HBSizeX = 9
local HBSizeY = 9
local HBSizeZ = 9
local HBTrans = 0.5
]]

local Frog = [[local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local character = game.Workspace.Const.Ignore.LocalCharacter
local partsToMove = {character.Middle, character.Bottom}
local maxSpeedBoostFactor = 1.1
local minSpeedBoostFactor = 0.8
local initialSpeedBoostFactor = 4
local isSliding = false
local activated = false
local speedhackStartTime = nil
local speedhackDuration = 1.2
local accelerationDuration = 0.03 -- Time to reach max speed

-- Phases for Y movement
local initialY = 0.23  -- Initial upward movement
local middleY = -0.18  -- Middle movement (hold at -0.1 for 0.4s)
local finalY = -0.4    -- Final downward movement

-- Timing settings for the phases
local middlePhaseTime = 0.52  -- Hold at Y = -0.1 for 0.4 seconds
local elapsedTimeAtMiddle = nil

local function calculateSpeedFactor(elapsedTime)
    if elapsedTime <= accelerationDuration then
        -- Accelerate from initial speed to max speed
        local progress = math.clamp(elapsedTime / accelerationDuration, 0, 1)
        return initialSpeedBoostFactor + (maxSpeedBoostFactor - initialSpeedBoostFactor) * progress
    else
        -- Decelerate after reaching max speed
        local decelerationTime = elapsedTime - accelerationDuration
        local remainingTime = speedhackDuration - accelerationDuration
        local progress = math.clamp(decelerationTime / remainingTime, 0, 1)
        return maxSpeedBoostFactor - (maxSpeedBoostFactor - minSpeedBoostFactor) * progress
    end
end

local function startSlide()
    isSliding = true
    speedhackStartTime = tick()
    elapsedTimeAtMiddle = nil  -- Reset time tracking for middle phase
end

local function stopSlide()
    isSliding = false
end

local function handleKeyInput()
    if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
        stopSlide()
        return
    end

    if UserInputService:IsKeyDown(Enum.KeyCode.W) and UserInputService:IsKeyDown(Enum.KeyCode.C) and UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
        if not isSliding then
            startSlide()
        end
    elseif isSliding and (not UserInputService:IsKeyDown(Enum.KeyCode.W) or not UserInputService:IsKeyDown(Enum.KeyCode.C) or not UserInputService:IsKeyDown(Enum.KeyCode.LeftShift)) then
        stopSlide()
    end
end

UserInputService.InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.LeftShift or input.KeyCode == Enum.KeyCode.C or input.KeyCode == Enum.KeyCode.W then
        activated = true
        handleKeyInput()
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.LeftShift or input.KeyCode == Enum.KeyCode.C or input.KeyCode == Enum.KeyCode.W then
        activated = false
        handleKeyInput()
    end
end)

RunService.RenderStepped:Connect(function(dt)
    local camera = game.Workspace.CurrentCamera
    local forwardVector = Vector3.new(camera.CFrame.LookVector.X, 0, camera.CFrame.LookVector.Z).Unit
    local rightVector = Vector3.new(camera.CFrame.RightVector.X, 0, camera.CFrame.RightVector.Z).Unit

    local moveVector = Vector3.new(0, 0, 0)

    if UserInputService:IsKeyDown(Enum.KeyCode.W) then
        moveVector = moveVector + forwardVector
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.S) then
        moveVector = moveVector - forwardVector
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.A) then
        moveVector = moveVector - rightVector
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.D) then
        moveVector = moveVector + rightVector
    end

    if moveVector.Magnitude > 0 then
        moveVector = moveVector.Unit
    end

    if activated and isSliding and moveVector.Magnitude > 0 and not UserInputService:IsKeyDown(Enum.KeyCode.Space) then
        local currentTime = tick()
        local elapsedTime = currentTime - (speedhackStartTime or currentTime)

        if elapsedTime < speedhackDuration then
            local speedFactor = calculateSpeedFactor(elapsedTime)

            local verticalMovement = initialY  -- Start from initialY

            -- Determine phase of movement: Upward -> Middle -> Downward
            if elapsedTime < speedhackDuration / 2 then
                -- Upward movement
                verticalMovement = initialY - (initialY * (elapsedTime / (speedhackDuration / 2)))
            elseif elapsedTime < (speedhackDuration / 2) + middlePhaseTime then
                -- Middle phase: hold at Y = -0.1 for 0.4 seconds
                verticalMovement = middleY
                elapsedTimeAtMiddle = elapsedTime  -- Track time during middle phase
            else
                -- Downward movement after holding at -0.1
                local downwardElapsed = elapsedTime - (speedhackDuration / 2) - middlePhaseTime
                verticalMovement = middleY + (finalY - middleY) * (downwardElapsed / (speedhackDuration / 2))
            end

            -- Update the moveVector with the new Y component
            moveVector = Vector3.new(moveVector.X, verticalMovement, moveVector.Z).Unit * speedFactor

            -- Apply the updated moveVector to the parts
            for _, part in ipairs(partsToMove) do
                part.Velocity = moveVector * 55 -- Adjust the scale factor for desired speed
            end
        else
            stopSlide()
        end
    end
end)
]]

local atvfly = [[local highlightedPart = nil
local selectionBox = Instance.new("SelectionBox")
selectionBox.LineThickness = 0.005
selectionBox.Color3 = Color3.new(0.46, 0.24, 0.76)
local mouse = game.Players.LocalPlayer:GetMouse()
local camera = workspace.CurrentCamera
local modelToMove = nil
local normalSpeed = 35
local sprintSpeed = 178
local downwardSpeed = 10
local upwardSpeed = downwardSpeed
local isPartSelected = false
local maxHeight = 0 -- Initial max height variable
local lerpSpeed = 0.2 -- Adjust this to control the smoothness of rotation


local selectableParts = {
    "Frame",
    "Grip",
    "HandleBars",
    "Plastics",
    "Plastics2",
    "Seat",
}

-- Function to check if a part name is selectable
local function isSelectablePart(partName)
    for _, name in ipairs(selectableParts) do
        if name == partName then
            return true
        end
    end
    return false
end

-- Function to disable collision and make transparent for wheel and rim parts
local function disableWheelsAndRims(model, disable)
    local wheelAndRimParts = {
        "BackLeftW",
        "BackRightW",
        "FrontLeftW",
        "FrontRightW",
        "LeftBackWH",
        "LeftFrontWH",
        "RightBackWH",
        "RightFrontWH",
        "BackLeftRim",
        "BackRightRim",
        "FrontLeftRim",
        "FrontRightRim"
    }
    for _, partName in ipairs(wheelAndRimParts) do
        local part = model:FindFirstChild(partName)
        if part then
            part.CanCollide = not disable
            part.Transparency = disable and 0.75 or 0 -- Adjust transparency
        end
    end
end

-- Find the model containing the part and set the selection box on it
local function findModel(part)
    while part and not part:IsA("Model") do
        part = part.Parent
    end
    return part
end

-- Function to reset the selection state
local function resetSelection()
    if modelToMove then
        if selectionBox.Parent then
            selectionBox.Parent = nil
        end
        if modelToMove.PrimaryPart then
            modelToMove.PrimaryPart.Anchored = true
        end
        disableWheelsAndRims(modelToMove, false)
        modelToMove = nil
    end
    highlightedPart = nil
    isPartSelected = false
end

-- Function to handle model destruction
local function monitorModelDestruction(model)
    if model and model.PrimaryPart then
        model.PrimaryPart.AncestryChanged:Connect(function(_, parent)
            if not parent then
                resetSelection() -- Reset selection if the model is destroyed
            end
        end)
    end
end

-- Detect key press to toggle part selection
local UserInputService = game:GetService("UserInputService")

UserInputService.InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.P then
        if isPartSelected then
            resetSelection()
            print("Selection reset.")
        else
            local target = mouse.Target
            if target and target:IsA("BasePart") then
                print("Target detected: " .. target.Name)

                if isSelectablePart(target.Name) then
                    highlightedPart = target
                    modelToMove = findModel(target)

                    if modelToMove then
                        print("Model detected: " .. modelToMove.Name)
                        
                        if modelToMove.PrimaryPart then
                            print("PrimaryPart detected: " .. modelToMove.PrimaryPart.Name)
                            selectionBox.Adornee = modelToMove.PrimaryPart
                            selectionBox.Parent = game.Workspace
                            modelToMove.PrimaryPart.Anchored = true
                            disableWheelsAndRims(modelToMove, true)
                            isPartSelected = true
                            maxHeight = modelToMove.PrimaryPart.Position.Y
                        else
                            print("No PrimaryPart found. Setting PrimaryPart dynamically.")
                            modelToMove.PrimaryPart = target
                            selectionBox.Adornee = modelToMove.PrimaryPart
                            selectionBox.Parent = game.Workspace
                            modelToMove.PrimaryPart.Anchored = true
                            disableWheelsAndRims(modelToMove, true)
                            isPartSelected = true
                            maxHeight = modelToMove.PrimaryPart.Position.Y
                        end
                    else
                        print("No model found for the target.")
                    end
                else
                    print("Target is not a selectable part.")
                end
            else
                print("No valid target detected.")
            end
        end
    end
end)


-- Movement control variables
local moveForward = false
local moveBackward = false
local moveRight = false
local moveLeft = false
local moveUp = false
local moveDown = false
local sprinting = false
local velocity = Vector3.new(0, 0, 0)
local decelerationDuration = 0.2
local decelerationRate = 1 / decelerationDuration

-- Define maximum pitch angle to limit upward and downward rotation on the Z-axis
local maxPitchAngleZ = math.rad(80.09)  -- Maximum angle in radians; adjust as needed

-- Update model movement (with nil checks)
local function updateModelMovement(deltaTime)
    if not modelToMove or not modelToMove.PrimaryPart or not modelToMove:IsDescendantOf(game.Workspace) then
        resetSelection()
        return
    end
        local cameraForward = camera.CFrame.LookVector
        local cameraRight = camera.CFrame.RightVector
        local direction = Vector3.new(0, 0, 0)

        -- Determine base speed based on sprinting state
        local baseSpeed = sprinting and sprintSpeed or normalSpeed

        -- WASD controls for forward, backward, right, and left movement
        if moveForward then
            direction = direction + (cameraForward * baseSpeed)
        end
        if moveBackward then
            direction = direction - (cameraForward * baseSpeed)
        end
        if moveRight then
            direction = direction + (cameraRight * baseSpeed)
        end
        if moveLeft then
            direction = direction - (cameraRight * baseSpeed)
        end

        -- Vertical movement limited by maxHeight
        if moveUp then
            maxHeight = math.max(maxHeight, modelToMove.PrimaryPart.Position.Y) -- Only set new max height if moving up
            if modelToMove.PrimaryPart.Position.Y < maxHeight then
                direction = direction + Vector3.new(0, upwardSpeed, 0)
            end
        elseif moveDown then
            direction = direction - Vector3.new(0, downwardSpeed, 0)
        end

        -- Prevent upward movement if the max height is exceeded
        if modelToMove.PrimaryPart.Position.Y >= maxHeight then
            direction = Vector3.new(direction.X, math.min(0, direction.Y), direction.Z)
        end

        -- Adjust speed if moving diagonally
        local isMovingDiagonally = (moveForward or moveBackward) and (moveLeft or moveRight)
        if isMovingDiagonally then
            direction = direction.Unit * (baseSpeed * 1)
        end

        -- Decelerate each velocity component separately if there's no input in that axis
        if direction.X == 0 then
            velocity = Vector3.new(velocity.X - velocity.X * decelerationRate * deltaTime, velocity.Y, velocity.Z)
        else
            velocity = Vector3.new(direction.X, velocity.Y, velocity.Z)
        end

        if direction.Y == 0 then
            velocity = Vector3.new(velocity.X, velocity.Y - velocity.Y * decelerationRate * deltaTime, velocity.Z)
        else
            velocity = Vector3.new(velocity.X, direction.Y, velocity.Z)
        end

        if direction.Z == 0 then
            velocity = Vector3.new(velocity.X, velocity.Y, velocity.Z - velocity.Z * decelerationRate * deltaTime)
        else
            velocity = Vector3.new(velocity.X, velocity.Y, direction.Z)
        end

        -- Stop velocity if it's below a small threshold
        if velocity.Magnitude < 0.1 then
            velocity = Vector3.new(0, 0, 0)
        end

        local newPosition = modelToMove.PrimaryPart.Position + (velocity * deltaTime)

        -- Calculate target rotation based on camera’s direction and clamp the pitch
        local cameraPitch = math.asin(camera.CFrame.LookVector.Y)
        local clampedPitch = math.clamp(cameraPitch, -maxPitchAngleZ, maxPitchAngleZ)
        
        local targetRotation = CFrame.new(newPosition, newPosition + Vector3.new(cameraForward.X, 0, cameraForward.Z).Unit)
        targetRotation = targetRotation * CFrame.Angles(clampedPitch, 0, 0) * CFrame.Angles(0, math.rad(90), 0)

        -- Lerp only the rotation part, preserving the deceleration of speed
        local finalRotation = modelToMove.PrimaryPart.CFrame:lerp(targetRotation, lerpSpeed)
        
        -- Set the model's position with the independently decelerated speed and the interpolated rotation
        modelToMove:SetPrimaryPartCFrame(CFrame.new(newPosition) * finalRotation.Rotation)
    end

-- Update max height when 'E' is pressed to increase and 'Ctrl' to decrease
UserInputService.InputBegan:Connect(function(input)
    if isPartSelected then
        if input.KeyCode == Enum.KeyCode.W then
            moveForward = true
        elseif input.KeyCode == Enum.KeyCode.S then
            moveBackward = true
        elseif input.KeyCode == Enum.KeyCode.D then
            moveRight = true
        elseif input.KeyCode == Enum.KeyCode.A then
            moveLeft = true
        elseif input.KeyCode == Enum.KeyCode.E then
            moveUp = true -- Start increasing height
        elseif input.KeyCode == Enum.KeyCode.LeftControl then
            moveDown = true -- Start decreasing height
        elseif input.KeyCode == Enum.KeyCode.LeftShift then
            sprinting = true -- Start sprinting
        end
    end
end)

-- Handle key input for stopping movement and adjusting max height
UserInputService.InputEnded:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.W then
        moveForward = false
    elseif input.KeyCode == Enum.KeyCode.S then
        moveBackward = false
    elseif input.KeyCode == Enum.KeyCode.D then
        moveRight = false
    elseif input.KeyCode == Enum.KeyCode.A then
        moveLeft = false
    elseif input.KeyCode == Enum.KeyCode.E then
        moveUp = false
    elseif input.KeyCode == Enum.KeyCode.LeftControl then
        moveDown = false
    elseif input.KeyCode == Enum.KeyCode.LeftShift then
        sprinting = false -- Stop sprinting
    end
end)

-- Continuously update model position and max height
game:GetService("RunService").RenderStepped:Connect(function(deltaTime)
    -- Ensure the model is valid and still in the workspace
    if modelToMove and not modelToMove:IsDescendantOf(game.Workspace) then
        resetSelection()
        return -- Exit early to avoid further processing
    end

    if isPartSelected then
        local currentPositionY = modelToMove.PrimaryPart.Position.Y

        -- Increase max height while 'E' is held down
        if moveUp then
            maxHeight = currentPositionY + upwardSpeed * deltaTime -- Lift the vehicle up
            modelToMove:SetPrimaryPartCFrame(modelToMove.PrimaryPart.CFrame + Vector3.new(0, upwardSpeed * deltaTime, 0)) -- Move the vehicle up
        end

        -- Decrease max height while 'Ctrl' is held down
        if moveDown then
            maxHeight = currentPositionY - downwardSpeed * deltaTime -- Lower the vehicle
            modelToMove:SetPrimaryPartCFrame(modelToMove.PrimaryPart.CFrame - Vector3.new(0, downwardSpeed * deltaTime, 0)) -- Move the vehicle down
        end

        -- Clamp maxHeight to ensure it doesn't go below 0
        maxHeight = math.max(maxHeight, 0)

        -- Additional height adjustment logic can be added here if needed
    end

    -- Update the model's movement
    updateModelMovement(deltaTime)
end)
]]
local longneck = [[local longNeckEnabled = false 

local function setLongNeck(enabled)
    longNeckEnabled = enabled
    local constraint = game:GetService("Workspace").Const.Ignore.LocalCharacter.Bottom.PrismaticConstraint
    if enabled then
        constraint.UpperLimit = 8.2
        constraint.LowerLimit = 8.2
    else
        constraint.UpperLimit = 3
        constraint.LowerLimit = 1.75
    end
end
local UserInputService = game:GetService("UserInputService")

UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if input.KeyCode == Enum.KeyCode.Z and not gameProcessedEvent then
        setLongNeck(not longNeckEnabled)
    end
end)

]]

local FullBright = [[local Light = game:GetService("Lighting")

function dofullbright()
Light.Ambient = Color3.new(1, 1, 1)
Light.ColorShift_Bottom = Color3.new(1, 1, 1)
Light.ColorShift_Top = Color3.new(1, 1, 1)
end

dofullbright()

Light.LightingChanged:Connect(dofullbright)]]

local esp = [[
local player = game.Players.LocalPlayer
local rootPart = workspace.Const.Ignore.FPSArms:WaitForChild("HumanoidRootPart")
local camera = workspace.CurrentCamera
local maxDistance = math.huge

local function createTextLabel(part, labelText, textColor)
    local textLabel = Drawing.new("Text")
    textLabel.Text = labelText
    textLabel.Color = textColor
    textLabel.Size = 15
    textLabel.Center = true
    textLabel.Outline = false
    textLabel.Font = 2
    textLabel.Visible = false

    local distanceLabel = Drawing.new("Text")
    distanceLabel.Color = textColor
    distanceLabel.Size = 14
    distanceLabel.Center = true
    distanceLabel.Outline = false
    distanceLabel.Font = 2
    distanceLabel.Visible = false

    local connection
    connection = game:GetService("RunService").RenderStepped:Connect(function()
        if not part.Parent then
            textLabel:Remove()
            distanceLabel:Remove()
            connection:Disconnect()
            return
        end

        local distance = (rootPart.Position - part.Position).Magnitude
        distanceLabel.Text = string.format("%d m", math.floor(distance)) 
        local screenPos, onScreen = camera:WorldToViewportPoint(part.Position)
        local cameraDistance = (camera.CFrame.Position - part.Position).Magnitude

        if onScreen and cameraDistance <= maxDistance then
            textLabel.Position = Vector2.new(screenPos.X, screenPos.Y - 20)
            textLabel.Visible = true

            distanceLabel.Position = Vector2.new(screenPos.X, screenPos.Y)
            distanceLabel.Visible = true
        else
            textLabel.Visible = false
            distanceLabel.Visible = false
        end
    end)
end

local function checkFolder(folder, labelText, textColor, targetPartName)
    for _, model in ipairs(folder:GetChildren()) do
        if model:IsA("Model") then
            local targetPart = model:FindFirstChild(targetPartName)
            if targetPart then
                createTextLabel(targetPart, labelText, textColor)
            end
        end
    end

    folder.ChildAdded:Connect(function(child)
        if child:IsA("Model") then
            local targetPart = child:FindFirstChild(targetPartName)
            if targetPart then
                createTextLabel(targetPart, labelText, textColor)
            end
        end
    end)
end

local boatsFolder = workspace:FindFirstChild("Boats")
local atvsFolder = workspace:FindFirstChild("ATVs")

if boatsFolder then
    checkFolder(boatsFolder, "Boat", Color3.new(0.57, 0.8, 0.25), "Hull")
end

if atvsFolder then
    checkFolder(atvsFolder, "ATV", Color3.new(1, 0, 1), "Plastics2")
end
local player = game.Players.LocalPlayer
local rootPart = workspace.Const.Ignore.FPSArms:WaitForChild("HumanoidRootPart")
local camera = workspace.CurrentCamera
local maxDistance = math.huge

-- Table to track ESP instances for cleanup
local activeESP = {}

local function createTextLabel(part, labelText, textColor)
    local textLabel = Drawing.new("Text")
    textLabel.Text = labelText
    textLabel.Color = textColor
    textLabel.Size = 15
    textLabel.Center = true
    textLabel.Outline = false
    textLabel.Font = 2
    textLabel.Visible = false

    local distanceLabel = Drawing.new("Text")
    distanceLabel.Color = textColor
    distanceLabel.Size = 14
    distanceLabel.Center = true
    distanceLabel.Outline = false
    distanceLabel.Font = 2
    distanceLabel.Visible = false

    local connection
    connection = game:GetService("RunService").RenderStepped:Connect(function()
        if not part.Parent then
            -- Remove ESP and disconnect
            textLabel:Remove()
            distanceLabel:Remove()
            connection:Disconnect()
            return
        end

        local distance = (rootPart.Position - part.Position).Magnitude
        distanceLabel.Text = string.format("%d m", math.floor(distance)) 
        local screenPos, onScreen = camera:WorldToViewportPoint(part.Position)
        local cameraDistance = (camera.CFrame.Position - part.Position).Magnitude

        if onScreen and cameraDistance <= maxDistance then
            textLabel.Position = Vector2.new(screenPos.X, screenPos.Y - 20)
            textLabel.Visible = true

            distanceLabel.Position = Vector2.new(screenPos.X, screenPos.Y)
            distanceLabel.Visible = true
        else
            textLabel.Visible = false
            distanceLabel.Visible = false
        end
    end)

    return { textLabel = textLabel, distanceLabel = distanceLabel, connection = connection }
end

local function cleanupESP(espData)
    if espData then
        espData.textLabel:Remove()
        espData.distanceLabel:Remove()
        espData.connection:Disconnect()
    end
end

local function checkFolder(folder, labelText, textColor, targetPartName)
    -- Monitor folder for models
    local function processModel(model)
        if model:IsA("Model") then
            local targetPart = model:FindFirstChild(targetPartName)
            if targetPart then
                -- Create ESP for the part and track it
                activeESP[model] = createTextLabel(targetPart, labelText, textColor)
            end
        end
    end

    for _, model in ipairs(folder:GetChildren()) do
        processModel(model)
    end

    folder.ChildAdded:Connect(function(child)
        processModel(child)
    end)

    folder.ChildRemoved:Connect(function(child)
        -- Clean up ESP if the model is removed from the folder
        cleanupESP(activeESP[child])
        activeESP[child] = nil
    end)
end

workspace.ChildAdded:Connect(function(child)
    if activeESP[child] then
        cleanupESP(activeESP[child])
        activeESP[child] = nil
    end
end)

workspace.ChildRemoved:Connect(function(child)
    cleanupESP(activeESP[child])
    activeESP[child] = nil
end)

-- Initialize folders
local boatsFolder = workspace:FindFirstChild("Boats")
local atvsFolder = workspace:FindFirstChild("ATVs")

if boatsFolder then
    checkFolder(boatsFolder, "Boat", Color3.new(0.57, 0.8, 0.25), "Hull")
end

if atvsFolder then
    checkFolder(atvsFolder, "ATV", Color3.new(1, 0, 1), "Plastics2")
end
--Loot/Esp
local ChamESP = {}
local isLootEspEnabled = true
local isBackpackEspEnabled = true
local camera = game.Workspace.CurrentCamera
local maxDistance = 500

function ChamESP.Create(Part, color)
    local Chams = {}

    for _, face in ipairs(Enum.NormalId:GetEnumItems()) do
        local surfaceGui = Instance.new("SurfaceGui")
        surfaceGui.Face = face
        surfaceGui.AlwaysOnTop = true
        surfaceGui.Parent = Part

        local frame = Instance.new("Frame")
        frame.Size = UDim2.new(1, 0, 1, 0)
        frame.BackgroundColor3 = color
        frame.BackgroundTransparency = 0.75
        frame.Parent = surfaceGui

        table.insert(Chams, {Part = Part, Gui = surfaceGui})
    end

    local function UpdateChams()
        if Part and Part:IsDescendantOf(game.Workspace) then
            local shouldUpdate = (isLootEspEnabled and color == Color3.fromRGB(255, 255, 0)) or 
                                 (isBackpackEspEnabled and color == Color3.fromRGB(255, 0, 0))
            local cameraDistance = (camera.CFrame.Position - Part.Position).Magnitude
            for _, chamData in ipairs(Chams) do
                chamData.Gui.Enabled = shouldUpdate and cameraDistance <= maxDistance
            end
        else
            for _, chamData in ipairs(Chams) do
                chamData.Gui.Enabled = false
            end
            if not Part or not Part:IsDescendantOf(game.Workspace) then
                for _, chamData in ipairs(Chams) do
                    chamData.Gui:Destroy()
                end
            end
        end
    end

    game:GetService("RunService").RenderStepped:Connect(UpdateChams)

    return Chams
end

local function checkAndLabelParts(model)
    local union = model:FindFirstChild("Union")
    local display = model:FindFirstChild("Display")
    local part = model:FindFirstChild("Part")

    if union and display and part and part:IsA("BasePart") then
        ChamESP.Create(part, Color3.fromRGB(255, 255, 0))
    end
end

local function checkAndLabelMaterials(part)
    if part.Material == Enum.Material.Fabric and
       part.Size == Vector3.new(2, 2, 0.7999954223632812) then
        ChamESP.Create(part, Color3.fromRGB(255, 0, 0))
    end
end

local function labelAllModels(parent)
    for _, model in ipairs(parent:GetChildren()) do
        if model:IsA("Model") then
            checkAndLabelParts(model)
        end
    end

    for _, part in ipairs(parent:GetDescendants()) do
        if part:IsA("BasePart") then
            checkAndLabelMaterials(part)
        end
    end
end

labelAllModels(game:GetService("Workspace"))

game.Workspace.ChildAdded:Connect(function(child)
    if child:IsA("Model") then
        checkAndLabelParts(child)
    end
end)

game.Workspace.DescendantAdded:Connect(function(descendant)
    if descendant:IsA("BasePart") then
        checkAndLabelMaterials(descendant)
    end
end)
]]
local aimbot = [[local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local Workspace = game:GetService("Workspace")  

-- SETTINGS
local DefaultFOV = 120 -- Default camera FOV
local RequiredDistance = 150 -- Default FOV circle radius at FOV = 120
local Running = false
local LockedTarget = nil
local BaseSensitivity = 0.02 -- Base sensitivity for default FOV
local SmoothFactor = 0.2 -- Adjusted smooth factor for better transitions

-- FOV CIRCLE
local fovCircle = Drawing.new("Circle")
fovCircle.Thickness = 0.8
fovCircle.NumSides = 100
fovCircle.Color = Color3.fromRGB(128, 0, 128)
fovCircle.Filled = false
fovCircle.Visible = true

-- SNAPLINE
local snapline = Drawing.new("Line")
snapline.Thickness = 1
snapline.Color = Color3.fromRGB(188, 12, 188)
snapline.Visible = false

-- LOGIC

local function updateFovCircle()
    local screenSize = Camera.ViewportSize
    local cameraFOV = Camera.FieldOfView

    -- Adjust FOV circle size based on camera's FOV
    fovCircle.Radius = RequiredDistance * (DefaultFOV / cameraFOV)
    fovCircle.Position = Vector2.new(screenSize.X / 2, screenSize.Y / 2)
end

RunService.RenderStepped:Connect(updateFovCircle)

local function CancelLock()
    LockedTarget = nil
    snapline.Visible = false
end

-- PREDICTION SETTINGS
local ProjectileSpeed = 9999999  -- Default speed
local ProjectileDrop = 0     -- Default drop

-- Weapon Attribute Detection Script
local function setWeaponAttributes()
    local fpsArms = workspace:WaitForChild("Const"):WaitForChild("Ignore"):WaitForChild("FPSArms")
    local handModel = fpsArms:FindFirstChild("HandModel")

    -- Reset function for easy resetting to defaults
    local function resetToDefault()
        ProjectileSpeed = 9999999
        ProjectileDrop = 0
    end

    -- If no HandModel, reset and exit
    if not handModel then
        resetToDefault()
        return
    end

    local weaponBody = handModel:FindFirstChild("Body") or handModel:FindFirstChild("Handle")

    -- If neither Body nor Handle exists, reset and exit
    if not weaponBody then
        resetToDefault()
        return
    end

    local bodySize = weaponBody.Size

    -- Detect weapon by body size and assign values
    if bodySize == Vector3.new(0.2068781554698944, 0.4731300473213196, 2.470069646835327) then -- AR-15
        ProjectileSpeed = 1300
        ProjectileDrop = 3
    elseif bodySize == Vector3.new(0.6530659198760986, 0.2612263858318329, 0.6530659198760986) then -- Bow
        ProjectileSpeed = 300
        ProjectileDrop = 3
    elseif bodySize == Vector3.new(0.10333291441202164, 0.5798616409301758, 0.814096987247467) then -- C9
        ProjectileSpeed = 600
        ProjectileDrop = 3
    elseif bodySize == Vector3.new(0.30750444531440735, 0.4284120500087738, 1.7146415710449219) then -- Crossbow
        ProjectileSpeed = 450
        ProjectileDrop = 3
    elseif bodySize == Vector3.new(0.9786123037338257, 0.44974008202552795, 0.21551764011383057) then -- M4A1
        ProjectileSpeed = 1300
        ProjectileDrop = 4
    elseif bodySize == Vector3.new(0.1646299660205841, 0.4369331896305084, 2.0044968128204346) then -- HMAR
        ProjectileSpeed = 1000
        ProjectileDrop = 3.5
    elseif bodySize == Vector3.new(0.2055438756942749, 0.47158217430114746, 1.4578189849853516) then -- Pipe Pistol
        ProjectileSpeed = 500
        ProjectileDrop = 3
    elseif bodySize == Vector3.new(1.0851157903671265, 0.3933083713054657, 0.16913115978240967) then -- Pipe SMG
        ProjectileSpeed = 600
        ProjectileDrop = 3
    elseif bodySize == Vector3.new(0.2341260015964508, 0.8559130430221558, 1.9701132774353027) then -- SCAR
        ProjectileSpeed = 1300
        ProjectileDrop = 4
    elseif bodySize == Vector3.new(0.15332837402820587, 0.7261472344398499, 1.2120881080627441) then -- USP-9
        ProjectileSpeed = 600
        ProjectileDrop = 3
    elseif bodySize == Vector3.new(0.13922937214374542, 0.5692847371101379, 1.3790713548660278) then -- UZI
        ProjectileSpeed = 600
        ProjectileDrop = 3
    elseif bodySize == Vector3.new(0.10446798801422119, 0.3589968681335449, 2.5119411945343018) then -- SVD
        ProjectileSpeed = 1400
        ProjectileDrop = 2
    elseif bodySize == Vector3.new(0.1130247637629509, 0.7977554202079773, 1.9025170803070068) then -- Energy Rifle
        ProjectileSpeed = 2000
        ProjectileDrop = 1.1
    elseif bodySize == Vector3.new(0.2261439561843872, 0.7247680425643921, 1.9429330825805664) then -- Shotgun
        ProjectileSpeed = 600
        ProjectileDrop = 2
    elseif bodySize == Vector3.new(0.1622471660375595, 0.6706026792526245, 3.4270622730255127) then -- Gauss Rifle
        ProjectileSpeed = 3000
        ProjectileDrop = 2
    elseif bodySize == Vector3.new(0.2031688541173935, 0.60098797082901, 1.6103566884994507) then -- Blunderbuss
        ProjectileSpeed = 300
        ProjectileDrop = 3.5
    elseif bodySize == Vector3.new(0.12275854498147964, 0.3104252815246582, 2.289419651031494) then -- Lever Action Rifle
        ProjectileSpeed = 1200
        ProjectileDrop = 1.5
    elseif bodySize == Vector3.new(0.5304766297340393, 0.5304766297340393, 4.266228675842285) then -- RPG
        ProjectileSpeed = 700
        ProjectileDrop = 3
    else
        resetToDefault() -- If no matching size, revert to default
    end

end

-- Connect to the Heartbeat event for continuous execution
game:GetService("RunService").Heartbeat:Connect(function()
    setWeaponAttributes()  -- Update weapon attributes every frame
end)


local previousPositions = {} -- Store previous positions for velocity calculation

local function calculateVelocity(part)
    local currentTime = tick()
    local previousData = previousPositions[part] or {Position = part.Position, Time = currentTime}
    local timeDifference = currentTime - previousData.Time

    local velocity = Vector3.new(0, 0, 0)
    if timeDifference > 0 then
        velocity = (part.Position - previousData.Position) / timeDifference
    end

    -- Update stored data
    previousPositions[part] = {Position = part.Position, Time = currentTime}
    return velocity
end

local function predictTargetPosition(target, projectileSpeed, projectileDrop, middlePartPosition)
    if not target then return end

    -- Calculate velocity using previous positions
    local velocity = calculateVelocity(target)

    -- Calculate distance between the middle part and the target
    local distance = (middlePartPosition - target.Position).Magnitude

    -- Time to hit based on projectile speed and distance
    local timeToHit = distance / projectileSpeed

    -- Predict future position based on calculated velocity and time to hit
    local futurePosition = target.Position + velocity * timeToHit

    -- Adjust for projectile drop over time
    local drop = (0.5 * projectileDrop * timeToHit * timeToHit)
    futurePosition = futurePosition - Vector3.new(0, drop, 0) -- Subtract drop in Y-axis

    return futurePosition
end


-- PREDICTION SCRIPT (uses dynamic ProjectileSpeed and ProjectileDrop)
local function predict_drop(part, entity, projectile_speed, projectile_drop)
    local distance = (Workspace.Const.Ignore.LocalCharacter.Middle.Position - part.Position).Magnitude
    local time_to_hit = (distance / projectile_speed)
    local final_projectile_speed = projectile_speed * (time_to_hit) * projectile_speed ^ 2
    time_to_hit = time_to_hit + (distance / final_projectile_speed)
    local drop_timing = projectile_drop ^ (time_to_hit * projectile_drop) - 1
    if not (drop_timing ~= drop_timing) then
        return drop_timing
    end
    return 0
end

-- Modify the GetPredictedPosition function to include the drop prediction logic
local function GetPredictedPosition(target)
    local middlePartPosition = Workspace.Const.Ignore.LocalCharacter.Middle.Position
    local predictedPosition = predictTargetPosition(target, ProjectileSpeed, ProjectileDrop, middlePartPosition)

    -- Calculate the projectile drop over time using the provided logic
    local drop = predict_drop(target, target.Parent, ProjectileSpeed, ProjectileDrop)
    predictedPosition = predictedPosition + Vector3.new(0, drop, 0) -- Apply the predicted drop in Y-axis

    return predictedPosition
end




local function GetClosestHead()
    local center = Vector2.new(fovCircle.Position.X, fovCircle.Position.Y)
    local closestTarget = nil
    local closestDistance = math.huge
    local cameraDirection = Camera.CFrame.LookVector

    local playersFolder = Workspace:FindFirstChild("Players")
    if playersFolder then
        for _, playerModel in ipairs(playersFolder:GetChildren()) do
            if playerModel:IsA("Model") and playerModel:FindFirstChild("Head") then
                local head = playerModel.Head
                local headPosition = head.Position
                local screenPos, onScreen = Camera:WorldToViewportPoint(headPosition)

                if onScreen then
                    local distanceFromCenter = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                    local headDirection = (headPosition - Camera.CFrame.Position).unit

                    -- Adjust detection radius based on FOV
                    local currentFOV = Camera.FieldOfView
                    local adjustedDistance = RequiredDistance * (DefaultFOV / currentFOV)

                    -- Calculate angle between camera direction and head direction
                    local angleBetween = math.acos(cameraDirection:Dot(headDirection))

                    -- Only lock onto players within a certain angle in front of the camera (e.g., 90 degrees or less)
                    local maxAngle = math.rad(45) -- 45 degrees in each direction (90-degree FOV)

                    if distanceFromCenter <= adjustedDistance and distanceFromCenter < closestDistance and angleBetween < maxAngle then
                        closestDistance = distanceFromCenter
                        closestTarget = head
                    end
                end
            end
        end
    end

    return closestTarget
end

-- Update Snapline
local function updateSnapline(target)
    if target then
        local targetPos = Camera:WorldToViewportPoint(target.Position)
        local center = Vector2.new(fovCircle.Position.X, fovCircle.Position.Y)
        snapline.From = center
        snapline.To = Vector2.new(targetPos.X, targetPos.Y)
        snapline.Visible = true
    else
        snapline.Visible = false
    end
end

-- Calculate sensitivity based on current FOV
local function calculateSensitivity()
    local currentFOV = Camera.FieldOfView
    return BaseSensitivity * (currentFOV / DefaultFOV)
end

-- Check if the camera is looking at the target
local function isLookingAtTarget(target)
    local cameraDirection = -Camera.CFrame.LookVector  -- Negate the look vector
    local targetDirection = (target.Position - Camera.CFrame.Position).unit

    local angleBetween = math.acos(cameraDirection:Dot(targetDirection))
    local maxAngle = math.rad(10) -- Adjust this angle for sensitivity (e.g., 10 degrees)

    return angleBetween <= maxAngle
end

-- Check if the target is valid (still exists and has a 'Head' part)
local function isTargetValid(target)
    return target and target.Parent and target:IsDescendantOf(Workspace) and target:FindFirstChild("Head")
end

-- Main AimLock logic
-- Main AimLock logic with smoother transition
RunService.RenderStepped:Connect(function()
    -- Update the snapline for the locked target if present
    if Running and LockedTarget then
        updateSnapline(LockedTarget)
    else
        -- Otherwise, show the snapline to the closest target when not locking
        local closestHead = GetClosestHead()
        updateSnapline(closestHead)
    end

    if Running then
        -- Lock onto the closest head if no target is currently locked
        if not LockedTarget then
            LockedTarget = GetClosestHead()
        end

        if LockedTarget then
            if not isLookingAtTarget(LockedTarget) then
                -- Predict the target's position and move the mouse smoothly towards it
                local predictedPosition = GetPredictedPosition(LockedTarget)
                local targetPos = Camera:WorldToViewportPoint(predictedPosition)
                local mousePos = UserInputService:GetMouseLocation()

                -- Calculate the difference and apply smooth movement with interpolation
                local deltaX = (targetPos.X - mousePos.X) * calculateSensitivity() * SmoothFactor
                local deltaY = (targetPos.Y - mousePos.Y) * calculateSensitivity() * SmoothFactor

                -- Smoothly transition between predicted and normal position
                local smoothFactor = 0.2  -- Adjust this value for smoother transition
                deltaX = deltaX * smoothFactor + (1 - smoothFactor) * (targetPos.X - mousePos.X)
                deltaY = deltaY * smoothFactor + (1 - smoothFactor) * (targetPos.Y - mousePos.Y)

                -- Adjust vertical aim (Y position) based on predicted projectile drop
                if math.abs(deltaX) > 0.01 or math.abs(deltaY) > 0.01 then
                    mousemoverel(deltaX, deltaY)
                end
            end
        end
    end
end)

-- Input Handling
UserInputService.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        Running = true
        if not LockedTarget then
            LockedTarget = GetClosestHead()
        end
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        Running = false
        CancelLock()
    end
end)
 
]]
local hitbox = [[
-- Hitbox Settings
local SelectPart = "Head"
local HBTrans = 0.24
local Color = BrickColor.new("Red")

-- Hitbox sizes for each group
local sizes = {
    Players = Vector3.new(8, 5, 8),
    Scientists = Vector3.new(10, 6, 10),
    Psleepers = Vector3.new(7, 7, 7),
    Teammates = Vector3.new(0.001, 0.001, 0.001),
    Tsleepers = Vector3.new(0.001, 0.001, 0.001)
}

-- Groups to create hitboxes for
local groups = {
    Players = workspace.Players,
    Scientists = workspace.Scientists,
    Psleepers = workspace.Psleepers,
    Teammates = workspace.Teammates,
    Tsleepers = workspace.Tsleepers
}

-- Function to determine the hitbox properties based on the group
local function getHitboxProperties(model)
    for groupName, group in pairs(groups) do
        if model.Parent == group then
            return sizes[groupName], HBTrans, Color -- Use specific size for each group
        end
    end
    return Vector3.new(0.001, 0.001, 0.001), 1, Color -- Default size and transparency
end

-- Function to find the correct "Head" part in the model
local function findHeadPart(model)
    local headParts = {}
    for _, part in pairs(model:GetChildren()) do
        if part:IsA("Part") and part.Name == "Head" then
            table.insert(headParts, part)
        end
    end
    -- Prioritize a head part that has no children (or just the marker)
    for _, part in pairs(headParts) do
        if #part:GetChildren() == 0 or (part:GetChildren()[1].Name == "Fake" and #part:GetChildren() == 1) then
            return part
        end
    end
    return nil -- No valid "Head" found
end

-- Function to create the FakeHead hitbox
local function createFakeHead(model)
    local size, transparency, brickColor = getHitboxProperties(model)

    -- Create the FakeHead part
    local FakeHead = Instance.new("Part")
    FakeHead.Name = SelectPart
    FakeHead.Size = size
    FakeHead.CFrame = model.Torso.CFrame
    FakeHead.Anchored = true
    FakeHead.CanCollide = false
    FakeHead.Transparency = transparency
    FakeHead.BrickColor = brickColor
    FakeHead.Material = Enum.Material.ForceField
    FakeHead.Parent = model

    -- Create a marker for the Fake hitbox
    local subndom = Instance.new("Part")
    subndom.Name = "Fake"
    subndom.Parent = model
end

-- Function to update the existing hitbox
local function updateHitbox(model)
    local existingHead = findHeadPart(model)

    local fakeMarker = model:FindFirstChild("Fake")  -- Check for the marker

    if model:FindFirstChild("Torso") then
        -- Get new hitbox properties based on group
        local newSize, newTransparency, newColor = getHitboxProperties(model)

        -- Update existing head if found
        if existingHead then
            if existingHead.Material == Enum.Material.ForceField then
                -- Update properties if they have changed
                if existingHead.Size ~= newSize or existingHead.Transparency ~= newTransparency or existingHead.BrickColor ~= newColor then
                    existingHead.Size = newSize
                    existingHead.CFrame = model.Torso.CFrame
                    existingHead.Transparency = newTransparency
                    existingHead.BrickColor = newColor
                end
            end
        elseif not fakeMarker then
            -- Create a new FakeHead if the marker doesn't exist
            createFakeHead(model)
        end
    end
end

-- Function to handle the addition of models
local function onModelAdded(model)
    if model:IsA("Model") and model:FindFirstChild("Torso") then
        -- Only create the FakeHead if it doesn't exist
        if not model:FindFirstChild("Fake") then
            createFakeHead(model)
        end
    end
end

-- Initial hitbox creation for existing models
for groupName, group in pairs(groups) do
    for _, model in pairs(group:GetChildren()) do
        if model:IsA("Model") and model:FindFirstChild("Torso") then
            -- Create hitbox for existing models if no Fake marker
            if not model:FindFirstChild("Fake") then
                createFakeHead(model)
            end
        end
    end
end

-- Main loop to continuously update hitboxes
task.spawn(function()
    while wait(0.1) do  -- Adjusted wait time for performance
        for groupName, group in pairs(groups) do
            for _, model in pairs(group:GetChildren()) do
                if model:IsA("Model") and model:FindFirstChild("Torso") then
                    updateHitbox(model)  -- Update hitbox for existing models
                end
            end
        end
    end
end)

-- Monitor for model additions to create hitboxes accordingly
for groupName, group in pairs(groups) do
    group.ChildAdded:Connect(onModelAdded)  -- Connect to model added event
end

-- Monitor for model removals to update or remove hitboxes
for groupName, group in pairs(groups) do
    group.ChildRemoved:Connect(function(model)
        if model:IsA("Model") then
            updateHitbox(model)  -- Update hitbox properties if model was moved
        end
    end)
end
]]
---GUI STUFF
-- New example script written by wally
-- You can suggest changes with a pull request or something

local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'

local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

local Window = Library:CreateWindow({
    -- Set Center to true if you want the menu to appear in the center
    -- Set AutoShow to true if you want the menu to appear when it is created
    -- Position and Size are also valid options here
    -- but you do not need to define them unless you are changing them :)

    Title = 'vexpub',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2
})

-- CALLBACK NOTE:
-- Passing in callback functions via the initial element parameters (i.e. Callback = function(Value)...) works
-- HOWEVER, using Toggles/Options.INDEX:OnChanged(function(Value) ... ) is the RECOMMENDED way to do this.
-- I strongly recommend decoupling UI code from logic code. i.e. Create your UI elements FIRST, and THEN setup :OnChanged functions later.

-- You do not have to set your tabs & groups up this way, just a prefrence.
local Tabs = {
    -- Creates a new tab titled Main
    Main = Window:AddTab('Main'),
    Main2 = Window:AddTab('Misc'),
    ['UI Settings'] = Window:AddTab('UI Settings'),
}

-- Groupbox and Tabbox inherit the same functions
-- except Tabboxes you have to call the functions on a tab (Tabbox:AddTab(name))
local LeftGroupBox = Tabs.Main:AddLeftGroupbox('HitBoxes')

-- We can also get our Main tab via the following code:
-- local LeftGroupBox = Window.Tabs.Main:AddLeftGroupbox('Groupbox')

-- Tabboxes are a tiny bit different, but here's a basic example:
--[[

local TabBox = Tabs.Main:AddLeftTabbox() -- Add Tabbox on left side

local Tab1 = TabBox:AddTab('Tab 1')
local Tab2 = TabBox:AddTab('Tab 2')

-- You can now call AddToggle, etc on the tabs you added to the Tabbox
]]

-- Groupbox:AddToggle
-- Arguments: Index, Options
LeftGroupBox:AddToggle('MyToggle', {
    Text = 'HIt',
    Default = true, -- Default value (true / false)
    Tooltip = 'This is a tooltip', -- Information shown when you hover over the toggle

    Callback = function(Value)
        print('[cb] MyToggle changed to:', Value)
    end
})


-- Fetching a toggle object for later use:
-- Toggles.MyToggle.Value

-- Toggles is a table added to getgenv() by the library
-- You index Toggles with the specified index, in this case it is 'MyToggle'
-- To get the state of the toggle you do toggle.Value

-- Calls the passed function when the toggle is updated
Toggles.MyToggle:OnChanged(function()
    -- here we get our toggle object & then get its value
    print('MyToggle changed to:', Toggles.MyToggle.Value)
end)

-- This should print to the console: "My toggle state changed! New value: false"
Toggles.MyToggle:SetValue(false)

-- 1/15/23
-- Deprecated old way of creating buttons in favor of using a table
-- Added DoubleClick button functionality

--[[
    Groupbox:AddButton
    Arguments: {
        Text = string,
        Func = function,
        DoubleClick = boolean
        Tooltip = string,
    }

    You can call :AddButton on a button to add a SubButton!
]]

local MyButton = LeftGroupBox:AddButton({
    Text = 'HitBoxes',
    Func = function()
    Load(hitbox)()
    end,
    DoubleClick = false,
    Tooltip = 'HITBOXES ON'
})



--[[
    NOTE: You can chain the button methods!
    EXAMPLE:

    LeftGroupBox:AddButton({ Text = 'Kill all', Func = Functions.KillAll, Tooltip = 'This will kill everyone in the game!' })
        :AddButton({ Text = 'Kick all', Func = Functions.KickAll, Tooltip = 'This will kick everyone in the game!' })
]]

-- Groupbox:AddLabel
-- Arguments: Text, DoesWrap
LeftGroupBox:AddSlider('MySlider', {
    Text = 'Size',
    Default = 0,
    Min = 0,
    Max = 7,
    Rounding = 1,
    Compact = false,

    Callback = function(Value)
        print('[cb] MySlider was changed! New value:', Value)
    end
})

-- Groupbox:AddDivider
-- Arguments: None
LeftGroupBox:AddDivider()

--[[
    Groupbox:AddSlider
    Arguments: Idx, SliderOptions

    SliderOptions: {
        Text = string,
        Default = number,
        Min = number,
        Max = number,
        Suffix = string,
        Rounding = number,
        Compact = boolean,
        HideMax = boolean,
    }

    Text, Default, Min, Max, Rounding must be specified.
    Suffix is optional.
    Rounding is the number of decimal places for precision.

    Compact will hide the title label of the Slider

    HideMax will only display the value instead of the value & max value of the slider
    Compact will do the same thing
]]
local FreecamGroupBox = Tabs.Main:AddRightGroupbox('Freecamera')
local FreecamButton = FreecamGroupBox:AddButton({
    Text = 'Freecam',
    Func = function()
    Load(Freecam)()
    end,
    DoubleClick = false,
    Tooltip = 'ESP ON'
})



FreecamGroupBox:AddLabel('Press L', true)

local LeftGroupBox = Tabs.Main:AddLeftGroupbox('Setting Esp')
local ESPButton = LeftGroupBox:AddButton({
    Text = 'ATV/BOAT.ESP',
    Func = function()
    Load(esp)()
    end,
    DoubleClick = false,
    Tooltip = 'ESP ON'
})

-- Options is a table added to getgenv() by the library
-- You index Options with the specified index, in this case it is 'MySlider'
-- To get the value of the slider you do slider.Value

local Number = Options.MySlider.Value
Options.MySlider:OnChanged(function()
    print('MySlider was changed! New value:', Options.MySlider.Value)
end)

-- This should print to the console: "MySlider was changed! New value: 3"
Options.MySlider:SetValue(3)

-- Groupbox:AddInput
-- Arguments: Idx, Info
local ESP1Button = LeftGroupBox:AddButton({
    Text = 'TargetEsp',
    Func = function()
        Load(ESP1)()
    end,
    DoubleClick = false,
    Tooltip = 'ESP ON'
})

-- Groupbox:AddDropdown
-- Arguments: Idx, Info
local LeftGroupBox3 = Tabs.Main:AddLeftGroupbox('atv fly')
local MyButton = LeftGroupBox3:AddButton({
    Text = 'atv fly',
    Func = function()
        Load(atvfly)()
    end,
    DoubleClick = false,
    Tooltip = 'ATV FLY ON'
})

LeftGroupBox3:AddLabel(' E up , ctrl down', true)
LeftGroupBox3:AddLabel('PRESS P TO USE ATV FLY',true)

local RightGroupBox8 = Tabs.Main:AddRightGroupbox('Esp')
local MyButton = RightGroupBox8:AddButton({
    Text = 'Frame',
    Func = function()
        Load(Frame)()
    end,
    DoubleClick = false,
    Tooltip = 'Frame'
})


local RightGroupBox8 = Tabs.Main:AddRightGroupbox('World')
local MyButton = RightGroupBox8:AddButton({
    Text = 'FullBright',
    Func = function()
        Load(FullBright)()
    end,
    DoubleClick = false,
    Tooltip = 'Fullbright on'
})

local RightGroupBox9 = Tabs.Main:AddRightGroupbox('Frog Jump')
local MyButton = RightGroupBox9:AddButton({
    Text = 'Kwa Kwa Kwa',
    Func = function()
        Load(Frog)()
    end,
    DoubleClick = false,
    Tooltip = 'Frog Jump on'
})

local TabBox = Tabs.Main:AddRightTabbox() -- Add Tabbox on right side
local LeftGroupBox5 = Tabs.Main:AddLeftGroupbox('long neck')
local MyButton = LeftGroupBox5:AddButton({
    Text = 'long neck',
    Func = function()
        Load(longneck)()
    end,
    DoubleClick = false,
    Tooltip = 'long neck on'
})

LeftGroupBox5:AddLabel('press Z', true)
local LeftGroupBox4 = Tabs.Main:AddLeftGroupbox('XRAY')
local MyButton = LeftGroupBox4:AddButton({
    Text = 'xray',
    Func = function()
        Load(xray)()
    end,
    DoubleClick = false,
    Tooltip = 'xray on'
})

LeftGroupBox4:AddLabel('press X', true)

local RightGroupBox51 = Tabs.Main:AddRightGroupbox('HitLogs')
local MyButtonButton = RightGroupBox51:AddButton({
    Text = 'HitLogs',
    Func = function()
    Load(hitlogs)()
    end,
    DoubleClick = false,
    Tooltip = 'HITLOGS ON'
})

local RightGroupBox4 = Tabs.Main:AddRightGroupbox('AimBot')
local MyButton = RightGroupBox4:AddButton({
    Text = 'AIM BOT',
    Func = function()
        Load(aimbot)()
    end,
    DoubleClick = false,
    Tooltip = 'AIMBOT ON'
})

local MyButton = RightGroupBox4:AddButton({
    Text = 'FOV AND ZOOM',
    Func = function()
        Load(fovzoom)()
    end,
    DoubleClick = false,
    Tooltip = 'FOV AND ZOOM ON'
})

local RightGroupBox52 = Tabs.Main:AddRightGroupbox('FPS')
local MyButtonButton = RightGroupBox52:AddButton({
    Text = 'FPS BOOST',
    Func = function()
    Load(fpsboost)()
    end,
    DoubleClick = false,
    Tooltip = 'FPS BOOST ON'
})




-- Library functions
-- Sets the watermark visibility
Library:SetWatermarkVisibility(true)

-- Example of dynamically-updating watermark with common traits (fps and ping)
local FrameTimer = tick()
local FrameCounter = 0;
local FPS = 60;

local WatermarkConnection = game:GetService('RunService').RenderStepped:Connect(function()
    FrameCounter += 1;

    if (tick() - FrameTimer) >= 1 then
        FPS = FrameCounter;
        FrameTimer = tick();
        FrameCounter = 0;
    end;

    Library:SetWatermark(('VexPub | %s fps | %s ms'):format(
        math.floor(FPS),
        math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue())
    ));
end);

Library.KeybindFrame.Visible = true; -- todo: add a function for this

Library:OnUnload(function()
    WatermarkConnection:Disconnect()

    print('Unloaded!')
    Library.Unloaded = true
end)

-- UI Settings
local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')
LeftGroupBox4:AddLabel('Keybind'):AddKeyPicker('KeyPicker', {
    -- SyncToggleState only works with toggles.
    -- It allows you to make a keybind which has its state synced with its parent toggle

    -- Example: Keybind which you use to toggle flyhack, etc.
    -- Changing the toggle disables the keybind state and toggling the keybind switches the toggle state

    Default = 'X', -- String as the name of the keybind (MB1, MB2 for mouse buttons)
    SyncToggleState = false,


    -- You can define custom Modes but I have never had a use for it.
    Mode = 'Toggle', -- Modes: Always, Toggle, Hold

    Text = 'Xray', -- Text to display in the keybind menu
    NoUI = false, -- Set to true if you want to hide from the Keybind menu,

    -- Occurs when the keybind is clicked, Value is `true`/`false`
    Callback = function(Value)
        print('[cb] Keybind clicked!', Value)
    end,

    -- Occurs when the keybind itself is changed, `New` is a KeyCode Enum OR a UserInputType Enum
    ChangedCallback = function(New)
        print('[cb] Keybind changed!', New)
    end
})

LeftGroupBox5:AddLabel('Keybind'):AddKeyPicker('KeyPicker', {
    -- SyncToggleState only works with toggles.
    -- It allows you to make a keybind which has its state synced with its parent toggle

    -- Example: Keybind which you use to toggle flyhack, etc.
    -- Changing the toggle disables the keybind state and toggling the keybind switches the toggle state

    Default = 'Z', -- String as the name of the keybind (MB1, MB2 for mouse buttons)
    SyncToggleState = false,


    -- You can define custom Modes but I have never had a use for it.
    Mode = 'Toggle', -- Modes: Always, Toggle, Hold

    Text = 'long neck', -- Text to display in the keybind menu
    NoUI = false, -- Set to true if you want to hide from the Keybind menu,

    -- Occurs when the keybind is clicked, Value is `true`/`false`
    Callback = function(Value)
        print('[cb] Keybind clicked!', Value)
    end,

    -- Occurs when the keybind itself is changed, `New` is a KeyCode Enum OR a UserInputType Enum
    ChangedCallback = function(New)
        print('[cb] Keybind changed!', New)
    end
})

RightGroupBox4:AddLabel('Keybind'):AddKeyPicker('KeyPicker', {
    -- SyncToggleState only works with toggles.
    -- It allows you to make a keybind which has its state synced with its parent toggle

    -- Example: Keybind which you use to toggle flyhack, etc.
    -- Changing the toggle disables the keybind state and toggling the keybind switches the toggle state

    Default = 'MB2', -- String as the name of the keybind (MB1, MB2 for mouse buttons)
    SyncToggleState = false,


    -- You can define custom Modes but I have never had a use for it.
    Mode = 'Hold', -- Modes: Always, Toggle, Hold

    Text = 'AimBot', -- Text to display in the keybind menu
    NoUI = false, -- Set to true if you want to hide from the Keybind menu,

    -- Occurs when the keybind is clicked, Value is `true`/`false`
    Callback = function(Value)
        print('[cb] Keybind clicked!', Value)
    end,

    -- Occurs when the keybind itself is changed, `New` is a KeyCode Enum OR a UserInputType Enum
    ChangedCallback = function(New)
        print('[cb] Keybind changed!', New)
    end
})





-- I set NoUI so it does not show up in the keybinds menu
MenuGroup:AddButton('Unload', function() Library:Unload() end)
MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'End', NoUI = true, Text = 'Menu keybind' })

Library.ToggleKeybind = Options.MenuKeybind -- Allows you to have a custom keybind for the menu

-- Addons:
-- SaveManager (Allows you to have a configuration system)
-- ThemeManager (Allows you to have a menu theme system)

-- Hand the library over to our managers
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

-- Ignore keys that are used by ThemeManager.
-- (we dont want configs to save themes, do we?)
SaveManager:IgnoreThemeSettings()

-- Adds our MenuKeybind to the ignore list
-- (do you want each config to have a different menu key? probably not.)
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })

-- use case for doing it this way:
-- a script hub could have themes in a global folder
-- and game configs in a separate folder per game
ThemeManager:SetFolder('MyScriptHub')
SaveManager:SetFolder('MyScriptHub/specific-game')

-- Builds our config menu on the right side of our tab
SaveManager:BuildConfigSection(Tabs['UI Settings'])

-- Builds our theme menu (with plenty of built in themes) on the left side
-- NOTE: you can also call ThemeManager:ApplyToGroupbox to add it to a specific groupbox
ThemeManager:ApplyToTab(Tabs['UI Settings'])

-- You can use the SaveManager:LoadAutoloadConfig() to load a config
-- which has been marked to be one that auto loads!
SaveManager:LoadAutoloadConfig()
